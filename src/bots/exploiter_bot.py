"""Exploiter bot designed to beat calling stations"""

from typing import Tuple
from ..core.player import Player
from ..core.gamestate import PublicGamestate


class ExploiterBot(Player):
    """Bot optimized to exploit calling station opponents

    Strategy:
    - Plays tight preflop (good starting hands only)
    - Never bluffs (opponent won't fold anyway)
    - Bets/raises heavily for value with strong hands
    - Folds weak hands aggressively to avoid paying off opponent
    - Maximizes value extraction on later streets
    """

    # Card rank values for hand strength evaluation
    RANK_VALUES = {
        '2': 2, '3': 3, '4': 4, '5': 5, '6': 6, '7': 7, '8': 8,
        '9': 9, 'T': 10, 'J': 11, 'Q': 12, 'K': 13, 'A': 14
    }

    def get_action(
        self,
        gamestate: PublicGamestate,
        hole_cards: Tuple[str, str]
    ) -> Tuple[str, int]:
        """Make decision based on hand strength and game state

        Args:
            gamestate: Current public game state
            hole_cards: This player's hole cards

        Returns:
            Tuple of (action_type, amount)
        """
        player_info = gamestate.player_public_infos[self.player_index]
        bet_to_call = gamestate.get_bet_to_call()
        amount_to_call = bet_to_call - player_info.current_bet
        current_street = gamestate.get_current_street()

        # Evaluate hand strength
        hand_strength = self._evaluate_hand_strength(hole_cards, gamestate.community_cards)

        # Preflop strategy
        if current_street == "preflop":
            return self._preflop_strategy(hand_strength, amount_to_call, gamestate)

        # Postflop strategy
        return self._postflop_strategy(hand_strength, amount_to_call, gamestate)

    def _evaluate_hand_strength(self, hole_cards: Tuple[str, str], community_cards: list) -> str:
        """Classify hand strength into categories

        Args:
            hole_cards: Player's two hole cards
            community_cards: Community cards on board

        Returns:
            Hand strength category: 'premium', 'strong', 'medium', 'weak', 'trash'
        """
        card1_rank = hole_cards[0][0]
        card2_rank = hole_cards[1][0]
        card1_suit = hole_cards[0][1]
        card2_suit = hole_cards[1][1]

        rank1_value = self.RANK_VALUES[card1_rank]
        rank2_value = self.RANK_VALUES[card2_rank]

        is_pair = card1_rank == card2_rank
        is_suited = card1_suit == card2_suit
        high_card = max(rank1_value, rank2_value)
        low_card = min(rank1_value, rank2_value)

        # Preflop hand strength
        if not community_cards:
            # Premium hands: AA, KK, QQ, AKs
            if is_pair and high_card >= 12:  # QQ+
                return 'premium'
            if high_card == 14 and low_card == 13 and is_suited:  # AKs
                return 'premium'

            # Strong hands: JJ, TT, AK, AQ, KQ
            if is_pair and high_card >= 10:  # TT, JJ
                return 'strong'
            if high_card == 14 and low_card >= 12:  # AQ, AK
                return 'strong'
            if high_card == 13 and low_card == 12:  # KQ
                return 'strong'

            # Medium hands: 99-77, AJ, AT, KJ, suited connectors
            if is_pair and high_card >= 7:
                return 'medium'
            if high_card == 14 and low_card >= 10:  # AJ, AT
                return 'medium'
            if high_card == 13 and low_card >= 11:  # KJ
                return 'medium'
            if is_suited and abs(rank1_value - rank2_value) <= 2 and low_card >= 8:
                return 'medium'

            # Weak hands: small pairs, A-high, suited aces
            if is_pair:
                return 'weak'
            if high_card == 14:  # Any ace
                return 'weak'

            return 'trash'

        # Postflop evaluation - simple heuristic based on board texture
        board_ranks = [card[0] for card in community_cards]
        board_suits = [card[1] for card in community_cards]

        # Check for pair on board
        has_pair_on_board = len(board_ranks) != len(set(board_ranks))

        # Check if we hit the board
        hit_top_pair = card1_rank in board_ranks or card2_rank in board_ranks
        has_overpair = is_pair and low_card > max(self.RANK_VALUES[r] for r in board_ranks)

        # Check for flush/straight draws
        flush_draw = is_suited and board_suits.count(card1_suit) >= 2

        # Premium postflop: overpair, top pair with good kicker
        if has_overpair:
            return 'premium'
        if hit_top_pair and high_card >= 12:  # Top pair with Q+ kicker
            return 'premium'

        # Strong: top pair decent kicker, two pair potential
        if hit_top_pair and high_card >= 10:
            return 'strong'

        # Medium: any pair, flush draw with overcards
        if hit_top_pair:
            return 'medium'
        if flush_draw and high_card >= 12:
            return 'medium'

        # Weak: high cards, backdoor draws
        if high_card >= 12:
            return 'weak'

        return 'trash'

    def _preflop_strategy(
        self,
        hand_strength: str,
        amount_to_call: int,
        gamestate: PublicGamestate
    ) -> Tuple[str, int]:
        """Preflop decision making

        Args:
            hand_strength: Evaluated hand strength
            amount_to_call: Amount needed to call
            gamestate: Current game state

        Returns:
            Tuple of (action_type, amount)
        """
        pot_size = gamestate.total_pot
        player_info = gamestate.player_public_infos[self.player_index]

        # Premium hands: Always raise for value
        if hand_strength == 'premium':
            if amount_to_call == 0:
                # Open raise to 3-4x BB
                raise_amount = gamestate.blinds[1] * 3
                return ('bet', raise_amount)
            else:
                # Re-raise
                raise_amount = amount_to_call * 3
                return ('raise', raise_amount)

        # Strong hands: Raise if not raised, call if raised
        if hand_strength == 'strong':
            if amount_to_call == 0:
                raise_amount = gamestate.blinds[1] * 3
                return ('bet', raise_amount)
            else:
                return ('call', 0)

        # Medium hands: Call small bets, fold to big bets
        if hand_strength == 'medium':
            if amount_to_call == 0:
                return ('check', 0)
            elif amount_to_call <= gamestate.blinds[1] * 2:
                return ('call', 0)
            else:
                return ('fold', 0)

        # Weak hands: Only play if cheap
        if hand_strength == 'weak':
            if amount_to_call <= gamestate.blinds[1]:
                return ('call', 0)
            else:
                return ('fold', 0)

        # Trash: fold
        if amount_to_call > 0:
            return ('fold', 0)
        return ('check', 0)

    def _postflop_strategy(
        self,
        hand_strength: str,
        amount_to_call: int,
        gamestate: PublicGamestate
    ) -> Tuple[str, int]:
        """Postflop decision making - maximize value, minimize bluffs

        Args:
            hand_strength: Evaluated hand strength
            amount_to_call: Amount needed to call
            gamestate: Current game state

        Returns:
            Tuple of (action_type, amount)
        """
        pot_size = gamestate.total_pot
        player_info = gamestate.player_public_infos[self.player_index]

        # Premium hands: Bet big for value
        if hand_strength == 'premium':
            if amount_to_call == 0:
                # Bet 75-100% of pot
                bet_amount = int(pot_size * 0.8)
                return ('bet', max(bet_amount, gamestate.minimum_raise_amount))
            else:
                # Raise calling stations when we have premium
                raise_amount = amount_to_call + int(pot_size * 0.5)
                return ('raise', max(raise_amount, gamestate.minimum_raise_amount))

        # Strong hands: Bet/call for value
        if hand_strength == 'strong':
            if amount_to_call == 0:
                # Bet 60% of pot
                bet_amount = int(pot_size * 0.6)
                return ('bet', max(bet_amount, gamestate.minimum_raise_amount))
            else:
                # Call - don't raise, but don't fold value
                return ('call', 0)

        # Medium hands: Play carefully, check-call small bets
        if hand_strength == 'medium':
            if amount_to_call == 0:
                return ('check', 0)
            elif amount_to_call <= pot_size * 0.4:
                return ('call', 0)
            else:
                return ('fold', 0)

        # Weak/trash: Give up (calling stations will punish weak hands)
        if amount_to_call > 0:
            return ('fold', 0)
        return ('check', 0)
